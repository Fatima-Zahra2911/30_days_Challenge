🚀 Day 13: React Hooks – useState & useEffect
Today, I explored two of the most important React Hooks: useState and useEffect. These hooks are essential for managing state and side effects in functional components.

📚 Topics Covered
✅ useState Hook
Learned how to declare state variables in functional components.

Used useState to:

Store and update dynamic data.

Re-render UI based on state changes.

✅ useEffect Hook
Understood the concept of side effects in React.

Used useEffect for:

Fetching data.

Updating the DOM.

Setting up timers or intervals.

Explored different useEffect dependencies:

[] – runs only once (on mount)

[stateVar] – runs when specific state changes

🛠️ Practice & Tasks
🔁 State Management
Created counters and toggles using useState.

Built input fields that dynamically reflect user data.

⏲️ Side Effects
Used useEffect to:

Log state changes.

Simulate data fetching with setTimeout.

Create a simple timer.

🧠 Key Takeaways
useState enables local state management in functional components.

useEffect handles side effects, replacing lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount.

Dependency arrays in useEffect are crucial for optimizing performance and preventing unnecessary rerenders.

Combining these hooks creates powerful, responsive UIs without needing class components.

🔗 Resources Used
📘 React Docs: useState

📘 React Docs: useEffect

🧑‍💻 React Hooks Tutorial – W3Schools

📌 Next Steps
Practice combining useState and useEffect in small apps.

Explore other hooks like useRef and useContext.

Start working on components that consume APIs using these hooks.

