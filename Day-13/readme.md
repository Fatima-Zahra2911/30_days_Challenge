ğŸš€ Day 13: React Hooks â€“ useState & useEffect
Today, I explored two of the most important React Hooks: useState and useEffect. These hooks are essential for managing state and side effects in functional components.

ğŸ“š Topics Covered
âœ… useState Hook
Learned how to declare state variables in functional components.

Used useState to:

Store and update dynamic data.

Re-render UI based on state changes.

âœ… useEffect Hook
Understood the concept of side effects in React.

Used useEffect for:

Fetching data.

Updating the DOM.

Setting up timers or intervals.

Explored different useEffect dependencies:

[] â€“ runs only once (on mount)

[stateVar] â€“ runs when specific state changes

ğŸ› ï¸ Practice & Tasks
ğŸ” State Management
Created counters and toggles using useState.

Built input fields that dynamically reflect user data.

â²ï¸ Side Effects
Used useEffect to:

Log state changes.

Simulate data fetching with setTimeout.

Create a simple timer.

ğŸ§  Key Takeaways
useState enables local state management in functional components.

useEffect handles side effects, replacing lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount.

Dependency arrays in useEffect are crucial for optimizing performance and preventing unnecessary rerenders.

Combining these hooks creates powerful, responsive UIs without needing class components.

ğŸ”— Resources Used
ğŸ“˜ React Docs: useState

ğŸ“˜ React Docs: useEffect

ğŸ§‘â€ğŸ’» React Hooks Tutorial â€“ W3Schools

ğŸ“Œ Next Steps
Practice combining useState and useEffect in small apps.

Explore other hooks like useRef and useContext.

Start working on components that consume APIs using these hooks.

